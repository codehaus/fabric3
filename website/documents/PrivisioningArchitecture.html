<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
 <meta http-equiv="content-type" content="text/html" />
 <meta name="description" content="Fabric3 website" />
 <meta name="keywords" content="Fabric3, SCA, SCA Implementation, Open Source" />
 <meta name="author" content="Fabric3 / Ratesh Bansal" />
 <link rel="stylesheet" type="text/css" href="../css/default.css" />
 <title>Fabric3 - Privisioning Architecture</title>
</head>

<body>
<div id="container">
<div id="main">
<div id="intro">
            <p><div class="section_1"><h1><a name="LeftHeader-fabric3"></a><img src="../img/banner.jpg" height="100" width="750"/></h1></div></p>
     </div><div class="clear"></div>


<div class="shortheaderstyle" style="font-size: 1.0em">
<table id="utop_nav" style="width: 100%;padding-right: 2mm">
 <tr>
  <td align="left" valign="middle">
   <div id="ubreadcrumbs">
    <a href="../home.html">Home</a>
                      &gt; <a href="../Docs.html">Docs</a>
                        &gt; <a href="">Privisioning Architecture</a>
                  </div>
  </td>
  <td align="right" valign="middle" id="quicklinks">
       <p><a href="../Roadmap.html" title="Roadmap">Roadmap</a> | <a href="../Docs.html" title="Docs">Docs</a> | <a href="../Downloads.html" title="Downloads">Downloads</a></p>
     </td>
 </tr>
</table>
</div>

<div class="content" style="padding-top: 3mm;">
          <p><img class="emoticon" src="http://docs.codehaus.org/images/icons/emoticons/warning.gif" height="16" width="16" align="absmiddle" alt="" border="0"></img> <b>This is a work in progress</b></p>

<p>This guide serves as an introduction to the Fabric3 provisioning architecture.</p>

<p>Whether Fabric3 is configured for a local or distributed domain topology, the fundamental provisioning architecture is the same. Specifically, a local domain topology is simply a degenerate case of a distributed domain. In Fabric3, components are provisioned in a series of steps where they are first contributed to the domain, processed, and then sent via a changeset (or changesets) to participant nodes. In the case of a single-VM toplogy, the controller and participant node are the same. </p>

<p>To best explain how this process works, it is useful to start with the end result, namely the runtime artifacts that are instantiated when a composite is activated in a domain.   </p>

<div class="section_3"><h3><a name="PrivisioningArchitecture-ComponentsandWires"></a>Components and Wires</h3>

<p>Given the following composite:<br></br>
<a name="PrivisioningArchitecture-example1"></a></p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">&lt;composite xmlns=<span class="code-quote">"http:<span class="code-comment">//www.osoa.org/xmlns/sca/1.0"</span> name=<span class="code-quote">"BazComposite"</span>&gt;
</span>    &lt;component name=<span class="code-quote">"FooComponent"</span>&gt;
        &lt;implementation.java class=<span class="code-quote">"foo.FooImpl"</span>/&gt;
        &lt;reference name=<span class="code-quote">"bar"</span> target=<span class="code-quote">"BarComponent"</span>/&gt;
    &lt;/component&gt;
    &lt;component name=<span class="code-quote">"BarComponent"</span>&gt;
        &lt;implementation.java class=<span class="code-quote">"bar.BarImpl"</span>/&gt;
    &lt;/component&gt;
&lt;/composite&gt;</pre>
</div></div>

<p>the provisioning process will result in the creation of two runtime artifacts of type <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/component/Component.java">Component</a>. Composites have no runtime counterpart as they are logical constructs. </p>

<p>Components have 0..n <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/wire/Wire.java">Wires</a>, which correspond to configured references specified in the composite. In the above example, <tt>FooCompoent</tt> will have a <tt>Wire</tt> corresponding to the "bar" reference. Wires contain a set of <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/wire/Interceptor.java">Interceptor</a> chains corresponding to operations on the reference type. Since interceptors are stateless, there exists one Wire per component reference in a runtime. </p>

<p>In the above example, a wire will be created for the bar reference with a terminating interceptor that is responsible for dispatching invocations to an instance of the target BarComponent (for a detailed description of the relationship between components and component implementation instances, see the SCA Assembly Specification downloadable from the <a href="http://www.osoa.org">OSOA website</a>.  </p>

<p>If the previous composite were modified to include a reference configured with the Hessian binding as in:</p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">&lt;!-- .... ---&gt;
&lt;component name=<span class="code-quote">"BarComponent"</span>&gt;
   &lt;implementation.java class=<span class="code-quote">"bar.BarImpl"</span>/&gt;
   &lt;reference name="someService&gt;
       &lt;<span class="code-keyword">interface</span>.java <span class="code-keyword">interface</span>=<span class="code-quote">"baz.SomeService"</span>/&gt;
       &lt;hessian:binding.hessian uri=<span class="code-quote">"http:<span class="code-comment">//someplace/SomeService"</span>/&gt;
</span>   &lt;/reference&gt;
&lt;/component&gt;</pre>
</div></div>

<p>One additional artifact would be provisioned to the participant: a <tt>Wire</tt> corresponding to the "someService" reference on <tt>BarComponent</tt> with a terminating interceptor responsible for flowing invocations over the Hessian transport to a remote service.  </p>

<p>If the composite were further modified composite to include a service as in:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">&lt;!-- .... ---&gt;
&lt;component name=<span class="code-quote">"FooComponent"</span>&gt;
   &lt;implementation.java class=<span class="code-quote">"foo.FooImpl"</span>/&gt;
   &lt;service name=<span class="code-quote">"FooService"</span>&gt;
      &lt;<span class="code-keyword">interface</span>.java <span class="code-keyword">interface</span>=<span class="code-quote">"foo.Foo"</span>/&gt;
      &lt;hessian:binding.hessian uri=<span class="code-quote">"/fooService"</span> /&gt;
   &lt;/service&gt;
   &lt;reference name=<span class="code-quote">"bar"</span> target=<span class="code-quote">"BarComponent"</span>/&gt;
&lt;/component&gt;</pre>
</div></div>

<p>An additional <tt>Wire</tt> would be provisioned to the participant with a head interceptor accesible from the binding transport and a terminating interceptor responsible for dispatching to an instance of <tt>FooComponent</tt> (how the head interceptor becomes available to the binding transport will be explained below). </p>

<p>Component type extensions are responsible for creating {{Component}}s and terminating interceptors for dispatching invocations to instances of their type. Binding extensions are responsible for supplying head and terminating interceptors that flow invocations from and to remote transports. </p>

<div class="panelMacro"><table class="tipMacro"><colgroup><col width="24"></col><col></col></colgroup><tr><td valign="top"><img src="http://docs.codehaus.org/images/icons/emoticons/check.gif" width="16" height="16" align="absmiddle" alt="" border="0"></img></td><td><b>Logical versus Physical</b><br></br>
<p>A key concept to bear in mind is that Fabric3 makes a fundamental distinction between the logical representation of a composite (services, components, references, bindings, etc.) and their physical manifestation on a participant node (components and wires). The provisioning process essentially involves transforming the logical representation of a composite in steps to its physical manifestation on a participant node or set of nodes. These steps are detailed below.    </p></td></tr></table></div>

</div><div class="section_3"><h3><a name="PrivisioningArchitecture-LoadingtheLogicalTypeModel"></a>Loading the Logical Type Model</h3>

<p>The first step in the provisioning process after a composite has been contributed to the domain is to load its SCDL file and process its component definitions and wires. Processing may include introspection of implementation artifacts such as Java classes to build up ComponentType information. The end-product of this load process is a logical type model which represents the set of <em>type</em> information for all SCA artifacts in the contribution (i.e. composites, components, ComponentTypes, etc.). The logical type model is a POJO-based in-memory representation of the SCA contribution. As a type model, it is analogous to Java reflection information.</p>

<p>Binding and component type extensions will typically "plug-into" this process by creating their own <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/loader/StAXElementLoader.java">StAXElementLoader</a> for specific XML element types, for example, <tt>binding.XXXX</tt> or <tt>implementation.XXXX</tt>. The output of these loaders is a logical model object representing the configuration information and extending <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/type/ModelObject.java">ModelObject</a> or one of its subtypes. Loaders follow the registry pattern as described <a href="PatternsAndAntiPatterns.html">here</a>.</p>

</div><div class="section_3"><h3><a name="PrivisioningArchitecture-ComponentInstantiation"></a>Component Instantiation</h3>

<p>After a composite has been contributed and its logical type model has been loaded, it may be activated in the domain, which may result in the creation of logical instances. Contribution and activation are analogous to loading a Java class in a classloader and instantiating an instance respectively. Activation will result in the creation of <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/instance/LogicalComponent.java">LogicalComponent</a>s, <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/instance/LogicalReference.java">LogicalReference</a>s, <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/instance/LogicalService.java">LogicalService</a>s, and <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/instance/LogicalBinding.java">LogicalBinding</a>s, with instance-specific information such as normalized property and reference overrides. The original type information introspected from the contribution will be available on their logical counterparts.    </p>

</div><div class="section_3"><h3><a name="PrivisioningArchitecture-GeneratingandProvisioningPhysicalChangesets"></a>Generating and Provisioning Physical Changesets</h3>

<p>After logical instances are created during activation, physical changesets are generated from that information. Physical changesets contain the information necessary to instantiate runtime artifacts on a participant node. For example, a subtype of <tt>PhysicalComponentDefinition</tt> will be generated from a LogicalComponent based on its implementation type. Likewise, <tt>PhysicalWireDefinition}}s will be generated from wires and may contain binding information if the wires are bound. For the <a href="#PrivisioningArchitecture-example1">example</a> at the outset of this guide, the physical changeset produced would contain two {{PhysicalComponentDefinition}}s and one {{PhysicalWireDefinition</tt> for to the "bar" reference on FooComponent. </p>

<p>Extensions provide generators for creating physical changset information. Specifically, component type extensions contribute <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/generator/ComponentGenerator.java">ComponentGenerator</a>s which produce subtypes of <tt>PhysicalComponentDefinition</tt>. Binding extensions contribute <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/generator/BindingGenerator.java">BindingGenerator</a>s which produce subtype of <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/physical/PhysicalWireSourceDefinition.java">PhysicalWireSourceDefinition </a> and <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/model/physical/PhysicalWireTargetDefinition.java">PhysicalWireTargetDefinition </a>. </p>

<p>The configuration information created by the generators is used to create runtime artifacts on participant nodes. Like loaders, generators follow the <a href="PatternsAndAntiPatterns.html">registry pattern</a>.</p>

<p>When generation is complete, the resulting changesets are serialized to participant nodes.      </p>

</div><div class="section_3"><h3><a name="PrivisioningArchitecture-BuildingComponents"></a>Building Components</h3>

<p>When a changeset arrives at a node, it is deserialized and <span class="error">[ComponentBuilder]</span>s are called to process <tt>PhysicalComponentDefinition}}s. {{ComponentBuilder}}s are specific to component types and are responsible for creating implementations of {{Component</tt>. They are dispatched to (following the registry pattern) based on the subtype of <tt>PhysicalComponentDefinition</tt>.</p>

</div><div class="section_3"><h3><a name="PrivisioningArchitecture-AttachingWires"></a>Attaching Wires</h3>

<p>Following the creation of components, wires are created for each <tt>PhysicalWireDefinition</tt> present in the changset. <a href="http://svn.codehaus.org/fabric3/modules/trunk/fabric3-spi/src/main/java/org/fabric3/spi/builder/component/WireAttacher.java">WireAttacher</a>s are then called to attach head and terminating interceptors. Component extensions, for example, would attach terminating interceptors responsible for dispatching to implementation instances. Binding extensions would attach terminating interceptors responsible for flowing invocations over a remote binding. <tt>WireAttachers</tt> are dispatched to (following the registry pattern) based on the subtype of <tt>PhysicalWireSourceDefinition</tt> and <tt>PhysicalWireTargetDefinition</tt>.  </p>

<p>Once wires have been attached, Components are started on the participant nodes.  </p>

</div><div class="section_3"><h3><a name="PrivisioningArchitecture-Summary"></a>Summary</h3>

<p>The distinction between the logical assembly model and physical runtime artifacts is one of the central tenets of the Fabric3 architecture. Extensions are responsible for loading logical representations from configuration or application artifact metadata (e.g. Java annotations) and generating corresponding physical metadata which is sent from the Controller to participant nodes via changesets. On a participant node, extensions are responsible for creating appropriate runtime artifacts based on the physical metadata contained in the changeset.</p>

</div>
</div>


</div>

<div id="sidebar">
<a href=""><img src="../img/fabric3-logo.jpg" width="100%" height="100" border="1"/></a>
<div class="navigation">
   <div class="section_1"><h1><a name="Navigation-Resources"></a>Resources</h1>

<p><a href="../Docs.html" title="Docs">Documentation</a><br></br>
<a href="../Downloads.html" title="Downloads">Downloads</a><br></br>
<a href="../SourceRepository.html" title="Source Repository">Source Repository</a><br></br>
<a href="http://www.osoa.org" title="SCA Specifications">SCA Specifications</a><br></br>
<a href="http://xircles.codehaus.org/projects/fabric3/lists">Mailing Lists</a><br></br>
<a href="http://jira.codehaus.org/browse/FABRICTHREE">JIRA</a><br></br>
<a href="http://bamboo.ci.codehaus.org/browse/FABRIC3">Continuous Integration</a><br></br>
<a href="http://www.opensource.org/licenses/apache2.0.php">License</a></p>
</div>
 </div>

<h4 class="headerstyle">Feeds</h4>
<ul>

 <li><a class="rss" href="http://docs.codehaus.org/spaces/rss.action?key=FABRICTHREE&amp;newPages=false">Site</a></li>
 <li><a class="rss" href="http://docs.codehaus.org/spaces/blogrss.action?key=FABRICTHREE">News</a></li>
</ul>

<h4 class="headerstyle">Blogs</h4>
<ul>
<li><a class="editPage" href="http://weblogs.java.net/blog/meeraj/archive/2008/01/introducing_ser.html" target="_blank">Meeraj's Blog</a></li>
 <li><a class="editPage" href="">Blog2</a></li>
</ul>
<h4 class="headerstyle">External Links</h4>
<ul>
 <li><a href="http://atlassian.com/">Atlassian</a></li>
 <li><a href="http://atlassian.com/confluence/">Confluence</a></li>
 <li><a href="http://www.codehaus.org/">Codehaus</a></li>
 <li><a href="http://www.jetbrains.com/idea/"><img src="http://www.jetbrains.com/idea/opensource/img/banners/idea88x31_blue.gif"></a></li>
</ul>
</div>
<div class="clear">&nbsp;</div>
</div>

<div id="footer">&copy; 2006 Codehaus Foundation. Original design by <a href="http://andreasviklund.com" class="credit">Andreas Viklund</a></div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-150515-1";
urchinTracker();
</script>
</body>
</html>
